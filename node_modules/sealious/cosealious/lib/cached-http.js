"use strict";

var axios = require("axios");
var CancelToken = axios.CancelToken;
var url = require("url");
var merge = require("merge");
var Promise = require("bluebird");
var qs = require("qs");
Promise.config({ cancellation: true });

function CachedError() {}

CachedError.prototype = Error.prototype;

function respond_from_cache(value) {
	return Promise[value instanceof CachedError ? "reject" : "resolve"](value);
}

var CachedHttp = function () {
	var cache = {};

	var pending = {};

	return {
		get: function get(url_arg, query, options) {
			var parsed_url = url.parse(url_arg, true);
			delete parsed_url.search;
			var merged_query = merge(true, parsed_url.query, query);
			var pathname = parsed_url.pathname;


			var hash = pathname + "|" + JSON.stringify(merged_query);

			if (pending[hash]) {
				return Promise.resolve(pending[hash]).finally(function () {
					return respond_from_cache(cache[hash]);
				});
			}
			if (cache[hash]) {
				return respond_from_cache(cache[hash]);
			}
			var promise = new Promise(function (resolve, reject, onCancel) {
				var source = CancelToken.source();
				onCancel(function () {
					delete cache[hash];
					delete pending[hash];
					source.cancel();
				});
				return axios.get(pathname + "?" + qs.stringify(merged_query), {
					cancelToken: source.token,
					options: options
				}).then(function (response) {
					var data = response.data;
					cache[hash] = data;
					delete pending[hash];
					resolve(data);
				}).catch(function (error) {
					var cached_err = Object.create(CachedError.prototype);
					Object.assign(cached_err, error);
					delete pending[hash];
					cache[hash] = cached_err;
					reject(cached_err);
				});
			});
			pending[hash] = promise.then(respond_from_cache).catch(function () {});
			return promise;
		},
		flush: function flush() {
			//resets cache
			cache = {};
		}
	};
}();

module.exports = CachedHttp;